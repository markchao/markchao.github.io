<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[redis笔记]]></title>
    <url>%2F2020%2F03%2F14%2Fredis%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[redis 基本知识 为什么有 redis 起初数据是存放在硬盘单一文件里的。 硬盘的两个指标 1. 带宽（也是吞吐，一般为百兆/秒） 2 .寻址时间(毫秒) 然而内存的寻址时间一般为纳秒级别 当文件越来越大时，查询会越来越慢，因为它要全量扫描（全量 io），根据硬件的约束，只会越来越慢 数据库 datapage 4k, 数据分治，创建索引 避免全量扫描，但是如果不对索引处理，还会是全量扫描索，这时候就在内存中增加了对索引（B+树/B 树）的数据结构，树干再内存里，叶子是索引数据，从而避免索引数据的全量 io 当表很大，增删改查一定会变慢吗？ 写会涉及到索引的变动，会变慢，但是读就不一定了，如果是只有一个链接，并且只是个简单的查询，并且 where 条件命中索引，那么它还是毫秒级的，不会慢，但当并发很大时，就算是索引命中，由于硬盘的带宽限制，它也会变得很慢 所以有了 内存型的 关系型数据库 HANA (SAP 公司)，就数据全部放到内存，但是很贵， 硬盘里的3T 数据 全部放到内存中，会比3T大还是小呢？ 答：会比3T小很多，因为内存存放数据，会有常量池，一些数量只需要保存一份就可以，其他用指针指向 ，数据可复用 把全部数据放在硬盘或者内存里是两个极端，放在硬盘里肯定会有慢的风险，放在内存里有太贵，所有就有了折中的办法：只把热点数据放到内存里，所以就有了与之相对应的技术（redis/memcache 等） Redis 为什么是 key value 关系型的数据库 会有约束，或者说是范式，为了防止冗余，如果 redis也设计成关系型的话，因为redis本身不会有太多的内存，有内存淘汰机制，当数据库不全的时候，就会出现问题，数据准不准，还要不要去数据库，所以没有更好的办法，还是保持 key value 不动，只关注数据自身 redis 是单线程还是多线程 worker 是单线程 从6.x版本开始，redis 开始了 io threads （io多线程，但是 worker 单线程） redis value有类型（string,hash,list, set ,zset)，且每种类型有自己的本地方法 memcache 数据向计算移动 redis 计算向数据移动 使用 redis 时应注意： redsi 可以启动多个，每个 redis 不要存放太多的数据（几G级别），风险分担，恢复也会很快 redis 的 io 性能来自于哪里？ 内核 NIO/EPOLL nio 是调用内核的 select（），有多少文件描述符就要传递多少，且每次都要传，内核就要遍历多少 epoll 首先epoll_create 在内存中开辟一个存放文件描述符空间并返回该空间的文件描述符 epoll_ctl 将要监控的文件描述符放到 开辟的内存空间中，每个描述符只需要调用一次 当有客户端链接 或者 发送数据时，内核会通过事件回调，将对应的文件描述符存放到一个内存空间中，等待用户 epoll_wait时返回 对应的文件描述符，然后用户再调用 read 方法读取数据 ​ 注意 所有的操作都是同步操作 工具Strace 追踪命令 命令：strace -ff -o ~/xx/out ./redis-server -ff 是监控所有的 包括线程 -o 是输出文件 xx 是文件存放的目录 out 是文件的前缀 ./redis-server 要追踪的命令 周老师课堂笔记课程链接]]></content>
      <tags>
        <tag>学习</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native 使用]]></title>
    <url>%2F2018%2F09%2F25%2Freact-native%2F</url>
    <content type="text"><![CDATA[##win10启动报错 不能用最新的版本 初始化命令应该是 react-native init ProjectName –version=0.55.4 夜神模拟器 adb connect 127.0.0.1:62001 逍遥模拟器 adb connect 127.0.0.1:21503 adb devices 检查是否连接成功 ##ios http图片不显示（http不能正常使用的解决方法） 在Info.plist中添加NSAppTransportSecurity(App Transport Security Settings)类型Dictionary。 在NSAppTransportSecurity(App Transport Security Settings)下添加NSAllowsArbitraryLoads(Allow Arbitrary Loads)类型Boolean,值设为YES。 重新执行 react-native run-ios ##报错（RootComponent.prototype）是因为App.js中的 export class App extends Component&lt;Props&gt;缺少了关键字default即修改成export default class App extends Component&lt;Props&gt;即可 ##npm设置淘宝镜像 1.得到原本的镜像地址 npm get registry > https://registry.npmjs.org/ 设成淘宝的 npm config set registry http://registry.npm.taobao.org/ yarn config set registry http://registry.npm.taobao.org/ 2.换成原来的 npm config set registry https://registry.npmjs.org/ ##使用native-base框架1.安装native-basenpm install native-base --savereact-native link //很重要 2.native-base自定义使用 node node_modules/native-base/ejectTheme.js运行上述命令时，名为native-base-theme的文件夹将复制到项目根目录。目录中有两个名为components和的文件夹variables。将下载的variables.js 复制到variables文件夹中使用示例 123456789101112131415161718192021222324import &#123; AppRegistry &#125; from &apos;react-native&apos;;import React, &#123; Component &#125; from &apos;react&apos;;import &#123; Container, Content, Text, StyleProvider &#125; from &apos;native-base&apos;;import getTheme from &apos;./native-base-theme/components&apos;;import material from &apos;./native-base-theme/variables/variables&apos;;import AppHeader from &apos;./src/components/appHeader&apos;;import AppFooter from &apos;./src/components/appFooter&apos;;import AppBody from &apos;./src/components/appBody&apos;;import App from &apos;./App&apos;;export default class MyProject extends Component &#123; render() &#123; return ( &lt;StyleProvider style=&#123;getTheme(material)&#125;&gt; &lt;Container&gt; &lt;AppHeader/&gt; &lt;AppBody/&gt; &lt;AppFooter/&gt; &lt;/Container&gt; &lt;/StyleProvider&gt; ); &#125;&#125;AppRegistry.registerComponent(&apos;Test2&apos;, () =&gt; MyProject); // Test2为项目名 一定注意 否则报错]]></content>
      <tags>
        <tag>全栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap的工作原理]]></title>
    <url>%2F2018%2F03%2F19%2FHashMap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[HashMap的工作原理是近年来常见的Java面试题。几乎每个Java程序员都知道HashMap，都知道哪里要用HashMap，知道Hashtable和HashMap之间的区别，那么为何这道面试题如此特殊呢？是因为这道题考察的深度很深。这题经常出现在高级或中高级面试中。投资银行更喜欢问这个问题，甚至会要求你实现HashMap来考察你的编程能力。ConcurrentHashMap和其它同步集合的引入让这道题变得更加复杂。让我们开始探索的旅程吧！ 先来些简单的问题“你用过HashMap吗？” “什么是HashMap？你为什么用到它？” 几乎每个人都会回答“是的”，然后回答HashMap的一些特性，譬如HashMap可以接受null键值和值，而Hashtable则不能；HashMap是非synchronized;HashMap很快；以及HashMap储存的是键值对等等。这显示出你已经用过HashMap，而且对它相当的熟悉。但是面试官来个急转直下，从此刻开始问出一些刁钻的问题，关于HashMap的更多基础的细节。面试官可能会问出下面的问题： “你知道HashMap的工作原理吗？” “你知道HashMap的get()方法的工作原理吗？” 你也许会回答“我没有详查标准的Java API，你可以看看Java源代码或者Open JDK。”“我可以用Google找到答案。” 但一些面试者可能可以给出答案，“HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。”这里关键点在于指出，HashMap是在bucket中储存键对象和值对象，作为Map.Entry。这一点有助于理解获取对象的逻辑。如果你没有意识到这一点，或者错误的认为仅仅只在bucket中存储值的话，你将不会回答如何从HashMap中获取对象的逻辑。这个答案相当的正确，也显示出面试者确实知道hashing以及HashMap的工作原理。但是这仅仅是故事的开始，当面试官加入一些Java程序员每天要碰到的实际场景的时候，错误的答案频现。下个问题可能是关于HashMap中的碰撞探测(collision detection)以及碰撞的解决方法： “当两个对象的hashcode相同会发生什么？” 从这里开始，真正的困惑开始了，一些面试者会回答因为hashcode相同，所以两个对象是相等的，HashMap将会抛出异常，或者不会存储它们。然后面试官可能会提醒他们有equals()和hashCode()两个方法，并告诉他们两个对象就算hashcode相同，但是它们可能并不相等。一些面试者可能就此放弃，而另外一些还能继续挺进，他们回答“因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。”这个答案非常的合理，虽然有很多种处理碰撞的方法，这种方法是最简单的，也正是HashMap的处理方法。但故事还没有完结，面试官会继续问： “如果两个键的hashcode相同，你如何获取值对象？” 面试者会回答：当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。面试官提醒他如果有两个值对象储存在同一个bucket，他给出答案:将会遍历链表直到找到值对象。面试官会问因为你并没有值对象去比较，你是如何确定确定找到值对象的？除非面试者直到HashMap在链表中存储的是键值对，否则他们不可能回答出这一题。 其中一些记得这个重要知识点的面试者会说，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。完美的答案！ 许多情况下，面试者会在这个环节中出错，因为他们混淆了hashCode()和equals()方法。因为在此之前hashCode()屡屡出现，而equals()方法仅仅在获取值对象的时候才出现。一些优秀的开发者会指出使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。 如果你认为到这里已经完结了，那么听到下面这个问题的时候，你会大吃一惊。“如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？”除非你真正知道HashMap的工作原理，否则你将回答不出这道题。默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。 如果你能够回答这道问题，下面的问题来了：“你了解重新调整HashMap大小存在什么问题吗？”你可能回答不上来，这时面试官会提醒你当多线程的情况下，可能产生条件竞争(race condition)。 当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。这个时候，你可以质问面试官，为什么这么奇怪，要在多线程的环境下使用HashMap呢？：） 热心的读者贡献了更多的关于HashMap的问题： 为什么String, Interger这样的wrapper类适合作为键？ String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。 我们可以使用自定义的对象作为键吗？ 这是前一个问题的延伸。当然你可能使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。 我们可以使用CocurrentHashMap来代替Hashtable吗？这是另外一个很热门的面试题，因为ConcurrentHashMap越来越多人用了。我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。看看这篇博客查看Hashtable和ConcurrentHashMap的区别。 我个人很喜欢这个问题，因为这个问题的深度和广度，也不直接的涉及到不同的概念。让我们再来看看这些问题设计哪些知识点： hashing的概念 HashMap中解决碰撞的方法 equals()和hashCode()的应用，以及它们在HashMap中的重要性 不可变对象的好处 HashMap多线程的条件竞争 重新调整HashMap的大小 总结HashMap的工作原理HashMap基于hashing原理，我们通过put()和get()方法储存和获取对象。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。 当两个不同的键对象的hashcode相同时会发生什么？ 它们会储存在同一个bucket位置的链表中。键对象的equals()方法用来找到键值对。 因为HashMap的好处非常多，我曾经在电子商务的应用中使用HashMap作为缓存。因为金融领域非常多的运用Java，也出于性能的考虑，我们会经常用到HashMap和ConcurrentHashMap。 参考 http://www.importnew.com/7099.html]]></content>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树遍历]]></title>
    <url>%2F2018%2F03%2F18%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"><![CDATA[二叉树的遍历分为以下三种： 先序遍历：遍历顺序规则为【根左右】 中序遍历：遍历顺序规则为【左根右】 后序遍历：遍历顺序规则为【左右根】 什么是【根左右】？就是先遍历根，再遍历左孩子，最后遍历右孩子； 举个例子，看下图（图从网上找的） 先序遍历：ABCDEFGHK 中序遍历：BDCAEHGKF 后序遍历：DCBHKGFEA 以中序遍历为例:中序遍历的规则是【左根右】，我们从root节点A看起； 此时A是根节点，遍历A的左子树； A的左子树存在，找到B，此时B看做根节点，遍历B的左子树； B的左子树不存在，返回B，根据【左根右】的遍历规则，记录B，遍历B的右子树； B的右子树存在，找到C，此时C看做根节点，遍历C的左子树； C的左子树存在，找到D，由于D是叶子节点，无左子树，记录D，无右子树，返回C，根据【左根右】的遍历规则，记录C，遍历C的右子树； C的右子树不存在，返回B，B的右子树遍历完，返回A； 至此，A的左子树遍历完毕，根据【左根右】的遍历规则，记录A，遍历A的右子树； A的右子树存在，找到E，此时E看做根节点，遍历E的左子树； E的左子树不存在，返回E，根据【左根右】的遍历规则，记录E，遍历E的右子树； E的右子树存在，找到F，此时F看做根节点，遍历F的左子树； F的左子树存在，找到G，此时G看做根节点，遍历G的左子树； G的左子树存在，找到H，由于H是叶子节点，无左子树，记录H，无右子树，返回G，根据【左根右】的遍历规则，记录G，遍历G的右子树； G的右子树存在，找到K，由于K是叶子节点，无左子树，记录K，无右子树，返回G，根据【左根右】的遍历规则，记录F，遍历F的右子树； F的右子树不存在，返回F，E的右子树遍历完毕，返回A； 至此，A的右子树也遍历完毕； 最终我们得到上图的中序遍历为BDCAEHGKF，无非是按照遍历规则来的；根据“中序遍历”的分析，相信先序遍历和后序遍历也可以轻松写出 参考 http://blog.csdn.net/soundwave_/article/details/53120766]]></content>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习二叉树]]></title>
    <url>%2F2018%2F03%2F17%2F%E5%AD%A6%E4%B9%A0%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[二叉树定义 二叉树（Binary Tree）是n（n≥0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。 二叉树特点：1.每个结点最多有两棵子树，所以二叉树中不存在度大于2的结点。没有子树或者有一棵子树是可以的，最多有两棵子树。2.左子树和右子树是有顺序的，次序不能颠倒。3.即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。4.二叉树的第i层至多有2的（i-1）次方个结点；深度为k的二叉树至多有2的k次 − 1个结点；对任何一棵二叉树T，如果其终端结点数为n0，度为2的结点数为n2，则n0 = n2 + 1。 二叉树具有五种基本形态 空二叉树 只有一个根结点 根结点只有左子树 根结点只有右子树 根结点既有左子树又有右子树 二叉树分类斜树所有的结点都只有左子树的二叉树叫左斜树。 所有的结点都是只有右子树的二叉树叫右斜树。这二者统称为斜树。 斜树有明显特点，每一层都只有一个结点，结点的个数和二叉树的深度相同。 斜树和线性表结构一样，线性表结构是树的一种特殊表现形式 满二叉树在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。 单是每个节点都存在左右子树，不能算是满n二叉树，还必须要所有的叶子结点都在同一层上，这样就做到了整棵树的平衡。 所以，满二叉树的特点是： 1.叶子只能出现在最下一层，出现在其他层就不能达到平衡； 2.非叶子结点的度一定是2； 3.在同样深度的二叉树中，满二叉树的结点最多，叶子数最多。 完全二叉树对一棵具有n个结点的二叉树 按层序编号 ，如果编号为i（1≤i≤n）的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这颗二叉树称为完全二叉树。 只有最下面的两层结点度小于2，且小于2的结点的子结点都有且只有左子树； 如何判断： 1. 如果一个结点有右孩子而没有左孩子，那么这棵树一定不是完全二叉树。 2. 如果一个结点有左孩子，而没有右孩子，那么按照层序遍历的结果，这个结点之后的所有结点都是叶子结点这棵树才是完全二叉树。 平衡二叉树平衡二叉树，又称AVL树。它或者是一棵空树，或者是具有下列性质的二叉树： 它的左子树和右子树都是平衡二叉树，且左子树和右子树的高度之差之差的绝对值不超过1 平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等 红黑树红黑树是每个节点都带有颜色属性的二叉查找树，颜色或红色或黑色。在二叉查找树强制一般要求以外，对于任何有效的红黑树我们增加了如下的额外要求: 1. 节点是红色或黑色 2. 根节点是黑色 3. 每个叶节点（NIL节点，空节点）是黑色的 4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点) 5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点 红黑树根节点是黑色的每个叶结点（叶结点即指树尾端NIL指针或NULL结点）都是黑的。如果一个结点是红的，那么它的两个儿子都是黑的。对于任意结点而言，其到叶结点树尾端NIL指针的每条路径都包含相同数目的黑结点 这里的NIL就是叶节点。有时候我们也称之为NULL节点，它只是指针而已 或者说成：每个叶子结点都带有两个空的黑色结点（被称为黑哨兵），如果一个结点n的只有一个左孩子，那么n的右孩子是一个黑哨兵；如果结点n只有一个右孩子，那么n的左孩子是一个黑哨兵。 一句话总结就是：有红必有黑，但有黑未必有红。小编是依据红黑树这个名字来记的。既然是红黑，自然有红就一定有黑。 参考： http://blog.csdn.net/dengpei187/article/details/51890339 https://baijiahao.baidu.com/s?id=1561409115312135&amp;wfr=spider&amp;for=pc]]></content>
      <tags>
        <tag>基础</tag>
      </tags>
  </entry>
</search>
